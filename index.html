<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OmniAudio Final Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.85); color: white; cursor: pointer; z-index: 10;
        }
        #overlay h1 { border: 2px solid white; padding: 20px; border-radius: 10px; margin-bottom: 10px; }
        #status {
            position: absolute; bottom: 20px; left: 20px; color: #0f0; 
            font-family: monospace; font-size: 14px; z-index: 5; 
            background: rgba(0,0,0,0.5); padding: 5px; pointer-events: none;
        }
        .error { color: #ff5555 !important; }
    </style>
</head>
<body>

<div id="overlay">
    <h1>Click to Start</h1>
    <p>Loaded: omni_fixed.js (v1.3.0)</p>
</div>

<div id="status">Waiting...</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script src="omni_fixed.js"></script>

<script>
    let scene, camera, renderer, controls;
    let video, videoTexture;
    let audioContext, foaRenderer, audioElement, audioSource;

    const overlay = document.getElementById('overlay');
    const statusDiv = document.getElementById('status');

    // >>> 你的文件名 <<<
    const VIDEO_FILENAME = 'video_360.mp4'; 
    const AUDIO_FILENAME = 'your_audio.flac'; 

    overlay.addEventListener('click', startExperience);

    function log(msg, isError = false) {
        console.log("[System]", msg);
        statusDiv.innerText = msg;
        if(isError) statusDiv.classList.add('error');
    }

    function startExperience() {
        overlay.style.display = 'none';

        if (typeof Omnitone === 'undefined') {
            log("Error: omni_fixed.js not loaded.", true);
            alert("omni_fixed.js 未加载！");
            return;
        }

        if (!Omnitone.createFOARenderer) {
            log("Error: Wrong Omnitone version.", true);
            alert("版本不对，请确认 omni_fixed.js 是 1.3.0 版本");
            return;
        }

        log("Initializing Engine...");
        initThreeJS();
        setTimeout(initAudio, 200);
    }

    function initThreeJS() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 0.1);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        video = document.createElement('video');
        video.crossOrigin = 'anonymous';
        video.loop = true;
        video.muted = true; 
        video.src = VIDEO_FILENAME;
        video.load(); 
        video.setAttribute('webkit-playsinline', 'webkit-playsinline'); 
        video.setAttribute('playsinline', 'playsinline');

        videoTexture = new THREE.VideoTexture(video);
        
        const geometry = new THREE.SphereGeometry(500, 60, 40);
        geometry.scale(-1, 1, 1); 
        const material = new THREE.MeshBasicMaterial({ map: videoTexture });
        const sphere = new THREE.Mesh(geometry, material);
        scene.add(sphere);

        // 初始化控制器
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.rotateSpeed = -0.25;

        window.addEventListener('resize', onWindowResize, false);
        animate();
    }

    function initAudio() {
        log("Setting up AudioContext...");

        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioContext = new AudioContext();
            if (audioContext.state === 'suspended') audioContext.resume();

            audioElement = document.createElement('audio');
            audioElement.src = AUDIO_FILENAME;
            audioElement.loop = true;
            audioElement.crossOrigin = 'anonymous';
            audioElement.load();

            log("Creating Renderer...");
            
            foaRenderer = Omnitone.createFOARenderer(audioContext);

            foaRenderer.initialize().then(function() {
                log("Audio Active: Rotate to hear changes.");
                
                audioSource = audioContext.createMediaElementSource(audioElement);
                audioSource.connect(foaRenderer.input);
                foaRenderer.output.connect(audioContext.destination);
                
                foaRenderer.setRenderingMode('ambisonic'); 
                
                const p1 = video.play();
                const p2 = audioElement.play();

                Promise.all([p1, p2]).catch(e => {
                    console.warn(e);
                    video.play(); audioElement.play();
                });
            }, function(err) {
                console.error("Init Error:", err);
                log("Init Failed.", true);
            });

        } catch (e) {
            console.error("System Error:", e);
            log("Error: " + e.message, true);
            if(video) video.play();
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        
        // 1. 更新控制器（处理鼠标拖拽）
        controls.update();
        
        // 2. 将最新的相机矩阵传给 Omnitone
        if (foaRenderer && foaRenderer.setRotationMatrixFromCamera) {
            // >>> 修复点：必须传 matrixWorld，不能传 camera 对象 <<<
            foaRenderer.setRotationMatrixFromCamera(camera.matrixWorld);
        }

        renderer.render(scene, camera);
    }
</script>
</body>
</html>